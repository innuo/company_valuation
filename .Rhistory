lda.predict[1:5,]
lda.pred=predict(lda.fit, Smarket.2005)
lda.pred[1:5,]
lda.pred[1:5]
class(lda.pred)
data.frame(lda.pred)[1:5,]
table(lda.pred$class, Smarket.2005$Direction)
mean(lda.pred$class == Smarket.2005$Direction)
library(class)
?knn
attach(Smarket)
clear
clear()
rm()
rm(*)
clear()
ls()
objects(2)
type(Lag1)
class(Lag1)
size(Lag1)
dim(Lag1)
ls()
require(ISLR)
require(class)
?Smarket
attach(Smarket)
xlag=cbind(Lag1, Lag2)
summary(xlag)
train=Year<2005
head(xlag)
knn.pred=knn(xlag[train], xlag[!train], Direction[train], k=1)
knn.pred=knn(xlag[train,], xlag[!train,], Direction[train], k=1)
table(knn.pred,Direction[!train])
mean(knn.pred==Direction[!train])
require
require(ISLR)
require(boot)
?cv.glm
plot(mpg-horsepower, data=Auto)
plot(mpg~horsepower, data=Auto)
glm.fit=glm(mpg~horsepower, data=Auto)
cv.glm(Auto,glm.fit)$delta
loocv=function(fit){}
loocv=function(fit){
h=lm.influence(fit)$h
mean(residuals(fit)/(1-h)^2)
}
loocv(glm.fit)
loocv=function(fit){
+ h=lm.influence(fit)$h
+ mean((residuals(fit)/(1-h))^2)
}
loocv(glm.fit)
loocv=function(fit){
h=lm.influence(fit)$h
mean((residuals(fit)/(1-h))^2)
}
loocv=function(fit){
h=lm.influence(fit)$h
mean((residuals(fit)/(1-h))^2)
}
loocv(glm.fit)
cv.error=rep(0,5)
plot(mpg~horsepower, data=Auto)
plot(glm.fit)
degree=1:5
for(d in degree){
glm.fit=glm(mpg~poly(horsepower,d), data=Auto)
cv.error[d]=loocv(glm.fit)
}
plot(degree, cv.error, type="b")
cv.error10=rep(0,5)
for(d in degree){
glm.fit=glm(mpg~poly(horsepower,d), data=Auto)
cv.error10[d]=cv.glm(Auto,glm.fit,K=10)$delta[1]
}
lines(degree,cv.error10, type="b", col="red")
require(ISLR)
require(ISLR)
summary(Hitters)
Hitters=na.omit(Hitters)
with(Hitters, sum(is.na(Salary)))
library(leaps)
regfit.full=regsubsets(Salary~., data=Hitters)
summary(regfit.full)
install.packages("leaps")
library(leaps)
regfit.full=regsubsets(Salary~., data=Hitters)
summary(regfit.full)
regfit.full=regsubsets(Salary~., data=Hitters, nvmax=19)
reg.summary=summary(regfit.full)
names(reg.summary)
plot(reg.summary$cp, xlab="Number of Variables", ylab="Cp")
which.min(reg.summary$cp)
points(10,reg.summary$cp[10],pch=20,col="red")
plot(regfit.full, scale="Cp")
coef(regfit.full, 10)
regfit.fwd=regsubsets(Salary~., data=Hitters, nvmax=19, 'method="forward"')
reg.summary=summary(regfit.fwd)
summary(regfit.fwd)
plot(regfit.fwd, scale="Cp")
regfit.fwd=regsubsets(Salary~., data=Hitters, nvmax=19, method="forward")
reg.summary=summary(regfit.fwd)
summary(regfit.fwd)
plot(regfit.fwd, scale="Cp")
dim(Hitters)
set.seed(1)
train=sample(seq(263), 180, replace=FALSE)
train
regfit.fwd=regsubsets(Salary~., data=Hitters[train], nvmax=19, method="forward")
regfit.fwd=regsubsets(Salary~., data=Hitters[train,], nvmax=19, method="forward")
val.errors=rep(NA,19)
x.test=model.matrix(Salary~., data=Hitters[-train,])
for(i in 1:19){
coefi=coef(regfit.fwd, id=i)
pred=x.test[,names(coefi)]
val.errors[i]=mean((Hitters$Salary[-train]-pred))2)
}
plot(sqrt(val.errors), ylab="Root MSE", ylim=c(300,400), pch=19,type="b")
points(sqrt(regfit.fwd$rss[-1]/180), col="blue", pch=19, type="b")
plot(sqrt(val.errors), ylab="Root MSE", ylim=c(300,400), pch=19,type="b")
for(i in 1:19){
coefi=coef(regfit.fwd, id=i)
pred=x.test[,names(coefi)]
val.errors[i]=mean((Hitters$Salary[-train]-pred))2)
}
for(i in 1:19){
coefi=coef(regfit.fwd, id=i)
pred=x.test[,names(coefi)]
val.errors[i]=mean((Hitters$Salary[-train]-pred)2)
}
for(i in 1:19){
coefi=coef(regfit.fwd, id=i)
pred=x.test[,names(coefi)]%*%coefi
val.errors[i]=mean((Hitters$Salary[-train]-pred)2)
}
for(i in 1:19){
coefi=coef(regfit.fwd, id=i)
pred=x.test[,names(coefi)]%*%coefi
val.errors[i]=mean((Hitters$Salary[-train]-pred)^2)
}
plot(sqrt(val.errors), ylab="Root MSE", ylim=c(300,400), pch=19,type="b")
points(sqrt(regfit.fwd$rss[-1]/180), col="blue", pch=19, type="b")
legend("topright", legend=c("Training", "Validation"), col=c("blue", "black"), pch=19)
library(glmnet)
install.packages("glmnet")
library(glmnet)
x=model.matrix(Salary~.,-1,data=Hitters)
y=Hitters$Salary
fit.ridge=glmnet(x,y,alpha=0)
fit.ridge=glmnet(x,y,alpha=0)
plot(fit.ridge, xvar="lambda", label=TRUE)
cv.ridge=cv.glmnet(x,y,alpha=0)
plot(cv.ridge)
fit.lasso=glmnet(x,y)
plot(fit.lasso, xvar="lambda", label=TRUE)
cv.lasso=cv.glmnet(x,y)
plot(cv.lasso)
coef(cv.lasso)
lasso.tr=glmnet(x[train,], y[train])
clear()
demo()
requrie(datasets)
require(datasets)
load(mtcars)
data(mtcars)
with(mtcars, tapply(hp, cyl, mean))
209.21-82.63
debug(ls)
ls()
mydata <- rnorm(1000)
plot(mydata)
install("network3D")
instal("networkD3")
install("networkD3")
install.packages("networkD3")
devtools::install_github('christophergandrud/networkD3')
install.packages("networkd3")
install.packages("networkD3")
install.packages("htmltools")
install.packages("htmlwidgets")
devtools::install_github('ramnathv/htmlwidgets')
install.packages(c("DBI", "devtools", "formatR", "httr", "maps", "markdown", "mime", "Rcpp", "RCurl", "rmarkdown", "swirl", "testthat"))
install.packages("htmlwidgets")
setwd("~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data")
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript3.R")
outcomeData <- read.csv("outcome-of-care-measures.csv", colClasses="character")
str(outcomeData)
head(outcomeData)
ncol(outcomeData)
nrow(outcomeData)
names(outcomeData)
class(outcomeData)
outcomeData[,11] <- as.numeric(outcomeData[,11])
hist(outcomeData[,11])
hist(outcomeData[,11])
names(outcomeData)[11]
outcomeData$State
levels(outcomeData$State)
split(outcomeData$State)
??split
?split
split(outcomeData, outcomeData$State)
as.factor(outcomeData$State)
stateFactors <- as.factor(outcomeData$State)
class(stateFactors)
nrow(stateFactors)
dim(stateFactors)
len(stateFactors)
str(stateFactors)
names(stateFactors)
factors(stateFactors)
factor(stateFactors)
levels(stateFactors)
stateIdVector <- levels(stateFactors)
?grep
grep("IL", stateIdVector)
grep("IZ", stateIdVector)
grepl("IZ", stateIdVector)
grepl("IL", stateIdVector)
grep("IZ", stateIdVector) == 0
grep("IL", stateIdVector) == 0
grep("IL", stateIdVector) == NULL
test <- grep("IL", stateIdVector)
test
test <- grep("IZ", stateIdVector)
test
len(test)
size(test)
length(test)
?is.empty
?stop
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/best.R')
best("BB", "heart attack")
best("NY", "hert attack")
stateIdVector
?splot
?split
outcomesByState <- split(outcomeData, stateIdVector)
str(outcomesByState)
outcomesByState <- outcomeData(outcomeData$State = "IL")
outcomesByState <- outcomeData(outcomeData$State == "IL")
outcomesByState <- outcomeData[outcomeData$State == "IL"]
outcomesByState <- outcomeData[,outcomeData$State == "IL"]
indx <- outcomeData$State == "IL"
outcomesByState <- outcomeData[indx,]
?as.logical
state <- "IL"
stateIndx <- ( outcomeData$State == state )
?min
outcomeIdVector <- c("heart attack", "heart failure", "pneumonia")
outcome <- "heart failure"
chkOutcome <- grep(outcome,outcomeIdVector)
chkOutcome
state <- "IL"
outcomeData <- read.csv("outcome-of-care-measures.csv", colClasses="character")
## Check that state and outcome are valid
# Load up valid state strings
stateFactors <- as.factor(outcomeData$State)
stateIdVector <- levels(stateFactors)
# Check for state validity
chkState <- grep(state,stateIdVector)
if ( length(chkState) == 0 )
stop("invalid state")
# Load up valid outcome strings
outcomeIdVector <- c("heart attack", "heart failure", "pneumonia")
# Load column Ids for corresponding mortality rate entries in the data
mortalityColIds <- c(11,17,23)
# Check for outcome validity
chkOutcome <- grep(outcome,outcomeIdVector)
if ( length(chkOutcome) == 0 )
stop("invalid outcome")
## Return hospital name in the state with lowest 30 day death rate
# Extract subframe for state selected
stateIndx <- ( outcomeData$State == state )
outcomeByState <- outcomeData[stateIndx, ]
# Identify the hospital name with the lowest mortality rate by outcome
mortalityVector <- outcomesByState[,mortalityColIds[chkOutcome]]
minMortality <- min(mortalityVector)
mortalityVector == min
mortalityVector == minMortality
bestHospitals <- outcomeData$Hospital.Name[minMortalityIndx]
minMortalityIndx <- ( mortalityVector == minMortality )
bestHospitals <- outcomeData$Hospital.Name[minMortalityIndx]
minMortalityIndx
outcomeByState$Hospital.Name
minMortalityIndx
outcomeByState$Hospital.Name[minMortalityIndx]
?sort
sortedHospitals <- sort(bestHospitals, decreasing = FALSE)
sortedHospitals[1]
bestHospitals <- outcomeByState$Hospital.Name[minMortalityIndx]
sortedHospitals <- sort(bestHospitals, decreasing = FALSE)
# Return first hospital from list
sortedHospitals[1]
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/best.R')
best("TX", "heart attack")
state ="TX"
state <- "TX"
outcome <- "heart attack"
outcomeData <- read.csv("outcome-of-care-measures.csv", colClasses="character")
stateFactors <- as.factor(outcomeData$State)
stateIdVector <- levels(stateFactors)
# Check for state validity
chkState <- grep(state,stateIdVector)
if ( length(chkState) == 0 )
stop("invalid state")
# Load up valid outcome strings
outcomeIdVector <- c("heart attack", "heart failure", "pneumonia")
# Load column Ids for corresponding mortality rate entries in the data
mortalityColIds <- c(11,17,23)
# Check for outcome validity
chkOutcome <- grep(outcome,outcomeIdVector)
if ( length(chkOutcome) == 0 )
stop("invalid outcome")
## Return hospital name in the state with lowest 30 day death rate
# Extract subframe for state selected
stateIndx <- ( outcomeData$State == state )
outcomeByState <- outcomeData[stateIndx, ]
# Select the vector of mortality rates for given outcome in state
mortalityVector <- outcomesByState[,mortalityColIds[chkOutcome]]
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/best.R')
best("TX", "heart attack")
best("TX", "heart failure")
?browser
source('~/.active-rstudio-document')
best("TX", "heart failure")
bestHospitals
mortalityVector
min(mortalityVector)
mortalityVector <- as.numeric(outcomeByState[,mortalityColIds[chkOutcome]])
mortalityVector
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/best.R')
best("TX", "heart failure")
best("TX", "heart failure")
# Find the lowest mortality rate
minMortality <- min(mortalityVector)
mortalityVectorNAIndx <- is.na(mortalityVector)
minMortality <- min(mortalityVector[mortalityVectorNAIndx!])
?!
}
??!!
}
help("!")
! TRUE
minMortality <- min(mortalityVector[!mortalityVectorNAIndx])
# Identify the one or more rows with the lowest mortality rate
minMortalityIndx <- ( mortalityVector == minMortality )
# Identify the hospital names with the lowest mortality rate by outcome
bestHospitals <- outcomeByState$Hospital.Name[minMortalityIndx]
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/best.R')
best("TX", "heart failure")
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/best.R')
best("TX", "heart failure")
best("TX", "heart attack")
best("MD", "heart attack")
best("MD", "pneumonia")
best("BB", "heart attack")
best("NY", "hert attack")
submit()
2
submit()
submit()
?sort
minMortality <- sort(mortalityVectorValid, decreasing = FALSE, index.return = TRUE)
mortalityVectorValid <- mortalityVector[!mortalityVectorNAIndx]
# Sort in ascending order of mortality rate
minMortality <- sort(mortalityVectorValid, decreasing = FALSE, index.return = TRUE)
?order
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankhospital.R')
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankhospital.R')
rankhospital("TX", "heart failure", 4)
?return
NA
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankhospital.R')
rankhospital("TX", "heart failure", 4)
# Extract subframe for state selected
stateIndx <- ( outcomeData$State == state )
outcomeByState <- outcomeData[stateIndx, ]
# Select the vector of mortality rates for given outcome in state
rankhospital("TX", "heart failure", 4000)
rankhospital("MD", "heart attack", "worst")
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankhospital.R')
rankhospital("MD", "heart attack", "worst")
rankhospital("MN", "heart attack", 5000)
submit()
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript3.R")
submit()
submit()
submit()
submit()
?for
}
??for
}
outcomeData <- read.csv("outcome-of-care-measures.csv", colClasses="character")
## Check that outcome is valid and load up state strings
# Load up valid state strings
stateFactors <- as.factor(outcomeData$State)
stateIdVector <- levels(stateFactors)
# Load up valid outcome strings
outcomeIdVector <- c("heart attack", "heart failure", "pneumonia")
# Load column Ids for corresponding mortality rate entries in the data
mortalityColIds <- c(11,17,23)
# Check for outcome validity
chkOutcome <- grep(outcome,outcomeIdVector)
if ( length(chkOutcome) == 0 )
resultStates <- sort(stateIdVector, decreasing = FALSE)
resultStates <- sort(stateIdVector, decreasing = FALSE)
resultHospitals <- rep("",length(resultStates))
resultFrame <- cbind(resultHospitals, resultStates)
class(resultFrame)
resultFrame <- as.data.frame(cbind(resultHospitals, resultStates))
resultFrame <- as.data.frame(cbind("hospital"=resultHospitals, "state"=resultStates))
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankall.R')
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankall.R')
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankall.R')
head(rankall("heart attack", 20), 10)
head(rankall("heart attack", 20), 10)
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankall.R')
head(rankall("heart attack", 20), 10)
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankall.R')
head(rankall("heart attack", 20), 10)
num
outcome
num
outcome
head(outcomeData,5)
outcomeByStateValid$Hospital.Name[numMortalityIndx]
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankall.R')
head(rankall("heart attack", 20), 10)
head(rankall("heart attack", 20), 10)
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankall.R')
head(rankall("heart attack", 20), 10)
rankhospital("AK", outcome, 20)
rankhospital("AR", outcome, 20)
rankhospital("AL", outcome, 20)
rankhospital("AZ", outcome, 20)
resultStates[i]
resultFrame$hospital[2]
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankall.R')
head(rankall("heart attack", 20), 10)
tail(rankall("pneumonia", "worst"), 3)
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankall.R')
tail(rankall("pneumonia", "worst"), 3)
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankall.R')
tail(rankall("pneumonia", "worst"), 3)
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankall.R')
source('~/Documents/Projects/Metonymy/R coding/JHU R programming course/ProgAssg3/rprog-data-ProgAssignment3-data/rankall.R')
tail(rankall("pneumonia", "worst"), 3)
tail(rankall("heart failure"), 10)
submit()
submit()
submit()
install.packages("swirl")
version
?exa
10^6
132*12
60*12
76*12
912/7
setwd("~/Documents/Projects/Metonymy/Demos/BayesianCompanyValuation/company_valuation/R")
train.data <-  readRDS("data/company_train_data.Rdata")
test.data <-  readRDS("data/company_test_data.Rdata")
setwd("~/Documents/Projects/Metonymy/Demos/BayesianCompanyValuation/company_valuation")
train.data <-  readRDS("data/company_train_data.Rdata")
test.data <-  readRDS("data/company_test_data.Rdata")
model <- learn.model(train.data, test.data)
source("R/learn_predict.R")
model <- learn.model(train.data, test.data)
saveRDS(model,"data/company_valuation_model.Rdata")
a <- predict.valuation(model, 1)
a$neighbor.ids
a$neighbor.similarities
mean(abs(a$neighbor.values - a$neighbor.predictions)/a$neighbor.values)
runApp("R/")
install.packages("shiny")
runApp("R/")
require(shiny)
runApp("R/")
test.data$ids
test.data$data[1]
test.data$data
test.data$data$Revenues[1]
test.data$data[,1]
test.data$data[1,]
test.data[1,]
test.data$data[1,]
shiny::runApp('R')
shiny::runApp('R')
dat <- cbind.data.frame(Name=test.data$ids[id],
test.data$data[id,])
id <- 1
dat <- cbind.data.frame(Name=test.data$ids[id],
test.data$data[id,])
shiny::runApp('R')
shiny::runApp('R')
shiny::runApp('R')
shiny::runApp('R')
id
shiny::runApp('R')
shiny::runApp('R')
result <- predict.valuation(model, 3)
test.data$ids[3]
test.data$target[3]
result <- predict.valuation(model, 1)
result <- predict.valuation(model, 2)
result <- predict.valuation(model, 3)
result <- predict.valuation(model, 4)
shiny::runApp('R')
